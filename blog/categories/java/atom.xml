<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: java | Rossi Oddet]]></title>
  <link href="http://roddet.github.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://roddet.github.com/"/>
  <updated>2014-05-21T01:43:46-04:00</updated>
  <id>http://roddet.github.com/</id>
  <author>
    <name><![CDATA[Rossi Oddet]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Oracle, Java & Internet des Objets]]></title>
    <link href="http://roddet.github.com/2014/05/oracle-java-internet-des-objets/"/>
    <updated>2014-05-13T08:41:00-04:00</updated>
    <id>http://roddet.github.com/2014/05/oracle-java-internet-des-objets</id>
    <content type="html"><![CDATA[<p>2014 c'est l'année d'<em>Internet Of Things</em> ou l'Internet des Objets ou encore l'Internet des Choses.</p>

<p>Tous les médias le disent, regarder <a href="http://www.lefigaro.fr/secteur/high-tech/2014/01/06/01007-20140106ARTFIG00069-l-annee-2014-placee-sous-le-signe-de-l-internet-des-objets.php">ici</a>, <a href="http://www.atlantico.fr/rdv/minute-tech/2014-sera-t-elle-annee-internet-choses-bertrand-duperrin-951986.html">là</a> ou encore <a href="http://blog.econocom.com/blog/2014-lannee-de-linternet-des-objets-grand-public/">là</a>.</p>

<p>C'est tellement l'année de l'Internet des Objets que :</p>

<ul>
<li>les conférences IT ont maintenant des tracks dédiés, <a href="http://cfp.devoxx.fr/devoxxfr2014/talks/hack"><em>Future Devoxx</em></a>,
<a href="http://cfp.devoxx.fr/devoxxfr2014/talks/hack">Un après-midi (Démo NAO, Objets connectés, Démo ORA Smart Glasses) au BreizhCamp</a>, etc.</li>
<li>des conférences dédiées fleurissent un peu partout dans le monde : <a href="http://blog.econocom.com/blog/2014-lannee-de-linternet-des-objets-grand-public/">IoT Conference</a>, <a href="http://www.internetofthingsasia.com/">IoT Asia</a>, <a href="http://iotday.org/">IoT Day</a>, etc.</li>
<li>des objets connectés en tout genre apparaissent. Il en y a tellement que <a href="http://www.amazon.com/b?node=9013937011">Amazon a créé une rubrique dédiée "Wearable Technology"</a>.</li>
</ul>


<p><a href="http://www.oracle.com/index.html">Oracle</a> l'a bien intégré et déploit beaucoup d'énergie sur ce sujet ces derniers temps comme nous allons le voir.</p>

<p><img class="center" src="/images/logos/FY14Duke14.png"></p>

<h2>Une gamme de produits Java Embedded</h2>

<p>Il y a plusieurs produits pour faire du Java en environnement embarqué :</p>

<ul>
<li><a href="http://www.oracle.com/technetwork/java/embedded/resources/se-embeddocs/index.html">Oracle Java SE Embedded</a> destiné à des appareils de 32MB ou plus.</li>
<li><a href="http://www.oracle.com/us/technologies/java/embedded/mobile-edition/overview/index.html">Oracle Java ME Embedded Client</a> pour des appareils de 8MB ou plus.</li>
<li><a href="http://www.oracle.com/technetwork/java/embedded/resources/me-embeddocs/index.html">Oracle Java ME Embedded</a> pour des appareils de 128 KB ou plus.</li>
<li><a href="http://www.oracle.com/technetwork/java/embedded/resources/java-embedded-suite/index.html">Oracle Java Embedded Suite</a>, c'est du Oracle Java SE Embedded + Java DB + Glassfish optimisé + JAX-RS (Jersey)</li>
<li><a href="http://docs.oracle.com/cd/E28280_01/doc.1111/e39318/toc.htm">Oracle Event Processing</a>, un serveur qui permet de supporter des applications event-driven qui font beaucoup de streaming de données.
Il n'y a pas le mot <em>réactif</em> mais ça ressemble dans l'idée ;)</li>
</ul>


<h2>Des événements Oracle IoT</h2>

<p>Des sessions en ligne sont régulièrement organisées :</p>

<ul>
<li><a href="https://blogs.oracle.com/java/entry/free_webinar_on_java_micro">Une session le 5 mai dernier</a></li>
<li><a href="https://blogs.oracle.com/java/entry/virtual_developer_day_java_2014">Un "Virtual Developer Day"</a> les 6 (Amérique), 14 (Europe/Afrique) et 21 mai (Asie).</li>
</ul>


<p>En Afrique, des sessions Java Embedded ont été organisées notamment :</p>

<ul>
<li>En Tunisie, les 18 et 19 avril, pendant <a href="http://jcertif.com/tunisie/2014/05/09/jcertif-tunisie/">JCertif Tunisie 2014</a></li>
<li>Au Congo-Brazzaville, en mars dernier, lors de la <a href="https://plus.google.com/events/c7fcpf5lb2dhclvbd4lesni8hng?cfem=1">Journée IoT Brazzaville</a></li>
<li>D'autres sessions sont prévues en juillet en Côte d'Ivoire et au Cameroun lors des prochains événement JCertif.</li>
</ul>


<p>Au Brésil, un <a href="https://blogs.oracle.com/java/entry/internet_of_things_iot_hackathon">Hackaton</a> a été organisé.</p>

<p>Le 17 et 18 mail prochain, <a href="http://www.oracle.com/index.html">Oracle</a> sera présent à l'événement <a href="http://makerfaire.com/">Make Faire</a> et va présenter un <a href="https://blogs.oracle.com/java/entry/java_shows_off_at_maker">IoT Java Panel</a>.</p>

<h2>Un Challenge IoT</h2>

<p>Un <a href="https://www.java.net/challenge">IoT Developer Challenge</a> organisé par <a href="http://www.oracle.com/index.html">Oracle</a> est en cours actuellement.
Les gagnants pourront aller à <a href="https://www.oracle.com/javaone/index.html">Java One 2014 !</a>.</p>

<p>Vous avez jusqu'au 30 mai pour participer.</p>

<h2>Un MOOC sur Java Embedded</h2>

<p>Un <a href="http://en.wikipedia.org/wiki/Massive_open_online_course">MOOC</a> sous le thème <em>Develop Java Embedded Applications Using a Raspberry Pi</em> est donné par <a href="http://www.oracle.com/index.html">Oracle</a> plusieurs fois dans l'année .</p>

<p>Il y en a eu un le 31 mars dernier, le prochain commence le 30 mai.</p>

<p>La formation dure 5 semaines et montre comment utiliser Java Embedded pour :</p>

<ul>
<li>Lire les différentes entrées de la Raspberry Pi</li>
<li>Manipuler des LED via les interfaces GPIO</li>
<li>Récupérer la température et la pression atmosphérique</li>
<li>Stocker et gérer des données</li>
<li>Envoyer des données à un client</li>
</ul>


<p>Vous pouvez vous inscrire <a href="https://apex.oracle.com/pls/apex/f?p=44785:145:0::::P145_EVENT_ID,P145_PREV_PAGE:861,143">ici</a>.</p>

<h2>Allez-vous être un acteur de l'Internet des Objets ?</h2>

<p>Si vous êtes développeur (quelque soit le langage/plateforme), l'Internet des Objets vous concerne directement que vous le vouliez ou non.</p>

<p>Le sujet étant jeune, il y a beaucoup d'opportunités, les technologies méritent d'être éprouvées.</p>

<p><a href="http://postscapes.com/javascript-and-the-internet-of-things">La communauté Javascript</a> est très active sur le sujet.</p>

<p>Pour les développeurs Java, une communité <a href="https://community.java.net/community/iot">IoT existe</a>. Le <a href="https://terrencebarr.wordpress.com/tag/java-embedded/">Blog de Terrence Barr</a>, est également une source d'informations intéressante.</p>

<p>Alors, ça vous tente du Java Embarqué ?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Devoxx France 2013 # Conférence # Java EE 7 plus en détail]]></title>
    <link href="http://roddet.github.com/2013/04/devoxxfr13-conference-javaee7-en-detail/"/>
    <updated>2013-04-06T14:14:00-04:00</updated>
    <id>http://roddet.github.com/2013/04/devoxxfr13-conference-javaee7-en-detail</id>
    <content type="html"><![CDATA[<p>Vous pouvez retrouvez la description de la session <a href="http://www.devoxx.com/display/FR13/Java+EE+7+en+detail">sur le site de Devoxx France</a>.</p>

<p><img class="center" src="http://blog.roddet.com/images/devoxxfr13/javaee7detail/affiche.jpg"></p>

<h2>Pourquoi j'ai choisi cette session ?</h2>

<p>En tant que développeur Java EE depuis plusieurs années, je souhaitais avoir les dernières nouvelles sur la version 7 à venir.</p>

<h2>Le présentateur</h2>

<p>David Delabassee <a href="https://twitter.com/delabassee">@delabassee</a> (<a href="http://www.devoxx.com/display/FR13/David+Delabassee">Bio</a>)</p>

<h2>Le succès de Java EE 6</h2>

<p>La session commence par un rappel du succès de Java EE 6 :</p>

<ul>
<li>Plus de 50 millions de téléchargements de composants Java EE 6</li>
<li>Choix N°1 pour le développement en entreprise</li>
<li>La version la plus rapide de Java EE</li>
</ul>


<h2>Le périmètre de Java EE 7</h2>

<p>Java EE 7 a deux objectifs :</p>

<ul>
<li>Améliorer la productivité des développements Java EE</li>
<li>Apporter un support de HTML 5 (WebSockets, JSON, Formulaires)</li>
</ul>


<p>Voici un vue d'ensemble de Java EE 7 :</p>

<p><img class="center" src="http://blog.roddet.com/images/devoxxfr13/javaee7detail/overview.jpg"></p>

<p>En vert les nouveaux modules :</p>

<ul>
<li>JSR 236 : Concurrency Utilities</li>
<li>JSR 352 : Batch Applications</li>
<li>JSR 353 : Java API for JSON</li>
<li>JSR 356 : Java API for WebSocket</li>
</ul>


<p>En orange les modules qui subissent les évolutions majeures :</p>

<ul>
<li>JAX-RS 2.0</li>
<li>EL 3.0</li>
<li>JMS 2.0</li>
</ul>


<p>En gris les modules mis à jour.</p>

<h2>Java API for JSON</h2>

<p>Cette nouvelle API permettra de parser et générer du JSON. Lors de sa 1ère version, le binding JSON vers objet Java ne sera pas présent. Il est prévu dans une version ultérieure.</p>

<p>Ce nouveau composant offrira une API en Streaming permettant de traiter de gros documents JSON.</p>

<h2>Java API for Websocket</h2>

<p>Elle est composée de 2 parties : client &amp; serveur.</p>

<h3>Exemple de partie serveur</h3>

<p>``` java
import javax.websocket.*;</p>

<p>@ServerEndPoint("/hello")
public class HelloBean {</p>

<pre><code>@OnMessage
public String sayHello(String name){
    return "Hello " + name;
}
</code></pre>

<p>}
```</p>

<h3>Exemple de partie cliente</h3>

<p>``` java
@ClientEndPoint
public class HelloClient {</p>

<pre><code>@OnMessage
public void message(String message, Session session) {
    // traitement de messages provenant du serveur
}
</code></pre>

<p>}
<code>
Pour lancer la connexion du client au serveur
</code>java
WebSocketContainer c = ContainerProvider.getWebSocketContainer();
c.connectToServer(HelloClient.class, "hello")
```</p>

<h2>Batch Applications</h2>

<p>Il s'agit ici d'apporter un standard dans la création des batchs en Java.</p>

<p>Ce composant apporte les concepts suivants :</p>

<ul>
<li>Job : Le processus du batch dans sa globalité</li>
<li>Step : un traitement indépendant d'un batch</li>
<li>JobOperator : Gestion de l'exécution du batch</li>
<li>JobRepository : Métadonnées des jobs</li>
</ul>


<p>Il y a 2 types de step :</p>

<ul>
<li>"Chunked" un traitement standard utilisant le pattern "reader-processor-writer"</li>
<li>"Batchlet" un traitement spécifique utilisant notre propre pattern</li>
</ul>


<p>Un job est paramétrable via un fichier XML. Exemple :
```xml
<job id="myJob"></p>

<pre><code>&lt;step id="init"&gt;
    &lt;chunk reader ref="MyReader" processor ref="MyProcessor" writer ref="MyWriter"/&gt;
    &lt;next on="initialized" to="process" /&gt;
    &lt;fail on="initError"/&gt;
&lt;/step&gt;
&lt;step id="process"&gt;
    &lt;batchlet ref="ProcessAndEmail" /&gt;
    &lt;end on="success"/&gt;
    &lt;fail on="*" exit-status="FAILURE"/&gt;
&lt;/step&gt;
</code></pre>

<p></job>
```
Il est possible de mettre en place des intercepteurs à différents niveaux (JobListener, StepListener, ChunkListener, etc...).</p>

<p>Pour lancer un Job :
```java
try {</p>

<pre><code>JobOperator jop = BatchRuntime.getJobOperator();
long jobId = jop.start("myJob"); // META-INF/batch.xml
</code></pre>

<p>} catch(JobStartException e) {</p>

<p>}</p>

<p>```
Il est possible de lancer les traitements d'un job en parallèle.</p>

<h2>Concurrency Utilities for Java EE</h2>

<p>L'objectif de cette JSR est d'offrir la possibilité d'exécuter des traitements concurrents dans un container Java EE sans compromettre son intégrité.
Elle sera cohérente avec l'API existante en Java SE (java.util.concurrent.*) en fournissant une version "managed" de java.util.concurrent.ExecutorService : ManagedExecutorService (récupérable via JNDI).</p>

<h2>JAX-RS 2.0</h2>

<h3>La partie cliente entre dans la standard.</h3>

<p>Exemple :
```java
Client client = ClientFactory.newClient();</p>

<p>String name = client.target(".../orders/{orderId}/customer")</p>

<pre><code>                .resolveTemplate("orderId", "10")
                .queryParam("shipped", "true")
                .request()
                .get(String.class)
</code></pre>

<p>```</p>

<h3>Des requêtes asynchrones possibles pour la partie cliente</h3>

<p>```java
Client client = ClientFactory.newClient();</p>

<p>Future<String> future = client.target(".../orders/{orderId}/customer")</p>

<pre><code>                .resolveTemplate("orderId", "10")
                .queryParam("shipped", "true")
                .request()
                .async()
                .get(
                    new InvocationCallBack&lt;String&gt;(){
                        public void completed(String result){

                        }
                        public void failed(InvocationException e){

                        }
                    }
                )
</code></pre>

<p>```</p>

<h3>Possibilité de créer des intercepteurs</h3>

<p>```java
public class MyInterceptor implements ReaderInterceptor {</p>

<pre><code>@Override
Object aroundReadFrom(ReaderInterceptorContext ctx){
    // Traitement de l'intercepteur
}
</code></pre>

<p>}
```</p>

<h2>JMS 2.0</h2>

<p>Ca faisait longtemps que JMS n'avait pas évolué.</p>

<p>L'objectif de Java EE 7 sur ce point :</p>

<ul>
<li>Simplifier l'API</li>
<li>Offrir la possibilité d'injecter des ressources</li>
<li>Les objets Connection, Session, etc... sont AutoCloseable (plus besoin de fermer explicitement ces ressources)</li>
</ul>


<h3>Injection de ressources par annotations</h3>

<p>```java
@Resource(lookup = "jms/connFactory")
ConnectionFactory cf;</p>

<p>@Resource(lookup = "jms/inboundQueue")
Destination dest;
```</p>

<h3>Création de JMSContext</h3>

<p>C'est une combinaison de la Connection et la Session.</p>

<p>```java
try(JMSContext context = cf.createContext();){</p>

<pre><code>//
</code></pre>

<p>}</p>

<p>```</p>

<h3>On peut envoyer un String directement sans passer par un objet spécifique</h3>

<p>```java
try(JMSContext context = cf.createContext();){</p>

<pre><code>context.createProducer().send(dest,"Hello");
</code></pre>

<p>}
```</p>

<h3>JMSContext peut être injecté</h3>

<p><code>java
@Inject
JMSContext context;
</code></p>

<h2>Bean Validation 1.1</h2>

<h3>Validation des paramètres d'une méthode</h3>

<p>```java
public void myMethod(</p>

<pre><code>@NotNull String name, 
@NotNull @Max("10")){
//
</code></pre>

<p>}</p>

<p>```</p>

<h3>Validation du résultat d'une méthode</h3>

<p>```java
@Future
public Date getProchainDevoxxFrance(){</p>

<pre><code>//
</code></pre>

<p>}
```</p>

<h2>Et bien sûr les autres nouveautés :</h2>

<ul>
<li>JSF 2.2 : support HTML5, Composant d'upload de fichier, ...</li>
<li>Servlet 3.1 : IO Non bloquant, ...</li>
<li>JPA 2.1 : Génération de schéma, ...</li>
<li>JTA 1.2 : déclaration de transaction en dehors des EJB, etc...</li>
<li>CDI 1.1 : Ordonnancement des intercepteurs, ...</li>
<li>EJB 3.2 : Asynchronisme, ...</li>
<li>EL 3.0 : Support des lambdas, Collection, ...</li>
<li>JavaMail 1.5</li>
</ul>


<h2>Petite réorganisation des profils Java EE</h2>

<h3>Web Profile</h3>

<ul>
<li>Servlet, JSF, JSP</li>
<li>WebSocket, JSON-P</li>
<li>JAX-RS</li>
<li>EL, Beans Validation</li>
<li>EJB (Lite), CDI, JTA, JPA, ...</li>
</ul>


<h3>Plateforme complète</h3>

<ul>
<li>Web Profile</li>
<li>Concurrency Utilities, Batch API</li>
<li>JMS, EJB, JAX-WS, JAXB, JavaMail, ...</li>
</ul>


<h2>Liens utiles</h2>

<ul>
<li><a href="http://glassfish.org/javaee7">Java EE 7</a></li>
<li><a href="https://blogs.oracle.com/theaquarium/">The Aquarium</a></li>
<li><a href="http://glassfish.java.net/adoptajsr/">Adopt-A-JSR</a></li>
<li><a href="http://glassfish.java.net/fishcat/">FishCat</a></li>
</ul>


<h2>RoadMap à court terme</h2>

<p>Les spécifications seront validées à la fin du mois d'Avril. La première version de GlassFish stable sortira quelques jours après.
JCache n'est pas dans le périmètre de Java EE 7.</p>

<h2>Bilan</h2>

<p>Session interressante qui présente en 1h les grandes nouveautés attendues pour Java EE 7. Après quelques recherches sur SlideShare, Parleys etc.. je n'ai pas retrouvé les slides de la présentation. Je l'ajouterai à ce billet lorsqu'il sera disponible.</p>

<p>Maintenant il ne reste plus qu'à approfondir chaque sujet et tester :)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Devoxx France 2013 # Tools in Action # Trucs et astuces avec Java et MongoDB sur Raspberry Pi]]></title>
    <link href="http://roddet.github.com/2013/04/devoxxfr13-tools-in-action-trucs-astuces-java-mongodb-raspberry-pi/"/>
    <updated>2013-04-05T13:54:00-04:00</updated>
    <id>http://roddet.github.com/2013/04/devoxxfr13-tools-in-action-trucs-astuces-java-mongodb-raspberry-pi</id>
    <content type="html"><![CDATA[<p>Vous pouvez retrouvez la description de la session <a href="http://www.devoxx.com/display/FR13/Trucs+et+astuces+avec+Java+et+MongoDB+sur+Raspberry+PI">sur le site de devoxx</a>.</p>

<h2>Pourquoi j'ai choisi cette session ?</h2>

<p>Une occasion de découvrir l'univers Raspberry Pi.</p>

<h2>L'animateur</h2>

<p><strong>Guillaume Scheibel</strong> <a href="https://twitter.com/g_scheibel">@g_scheibel</a> <a href="http://www.gscheibel.net">www.gsheibel.net</a></p>

<p><img class="center" src="http://blog.roddet.com/images/devoxxfr13/raspberrymongo/speaker.jpg"></p>

<h2>Raspberry Pi c'est quoi ?</h2>

<p><blockquote><p>Le Raspberry Pi est un ordinateur monocarte à processeur ARM conçu par le créateur de jeux vidéo David Braben, dans le cadre de sa fondation Raspberry Pi2.<br/>L'ordinateur a la taille d'une carte de crédit, il permet l'exécution de plusieurs variantes du système d'exploitation libre GNU/Linux et des logiciels compatibles. Il est fourni nu (carte mère seule, sans boîtier, alimentation, clavier, souris ni écran) dans l'objectif de diminuer les coûts et de permettre l'utilisation de matériel de récupération.</p><footer><strong>Wikipedia</strong> <cite><a href='http://fr.wikipedia.org/wiki/Raspberry_Pi'>fr.wikipedia.org/wiki/&hellip;</a></cite></footer></blockquote></p>

<h2>Raspberry Pi pour faire quoi ?</h2>

<ul>
<li>Du linux</li>
<li>Un serveur Git</li>
<li>Un serveur <a href="http://xbmc.org/">XBMC</a></li>
<li>Du code</li>
</ul>


<p>En fait, à nous d'inventer les usages :)</p>

<h2>Les modèles de Raspberry Pi</h2>

<h3>Modèle A (~ 25 euros)</h3>

<ul>
<li>Processeur 700 MHz</li>
<li>1 port HDMI</li>
<li>1 slot SDCARD</li>
<li>1 port USB</li>
<li>256MB de RAM</li>
</ul>


<h3>Modèle B (~ 35 euros)</h3>

<p>En mieux par rapport au modèle A :</p>

<ul>
<li>2 ports USB</li>
<li>512 MB de RAM</li>
<li>1 port Ethernet</li>
</ul>


<h2>Attention il faut des accessoires !</h2>

<p>Le Raspberry Pi est vendu dans le plus simple appareil.</p>

<p>Pour votre première commande, il vous faudra en plus :</p>

<ul>
<li>un carte SD</li>
<li>un cable d'alimentation (micro USB)</li>
<li>un boitier</li>
<li>des connectiques : HDMI, Ethernet, Clavier</li>
</ul>


<h2>Vous cherchez des informations sur le Raspberry Pi ?</h2>

<p>Le site <a href="http://elinux.org/RPi_Hub">http://elinux.org/RPi_Hub</a> est là pour vous aider.</p>

<h2>Les distributions Linux</h2>

<p>Il y a plus de 20 distributions Linux compatibles.</p>

<p>La distribution officielle est <a href="http://www.raspbian.org/">Raspbian</a>.</p>

<h2>Java</h2>

<p>On a le choix entre OpenJDK vs Oracle. Le présentateur a choisi Oracle.
La version compatible est 1.8 et il y a la preview de JavaFX.</p>

<h2>Java &amp; GPIO</h2>

<p>Des API Java permettent d'intéragir avec les pins GPIO.</p>

<p>Il y a par exemple <a href="http://pi4j.com/">Pi4J</a>.</p>

<h2>MongoDB</h2>

<p>Raspberry Pi n'est pas compatible avec les versions de Mongo officielles.</p>

<p>Un projet fait le portage de MongoDB sur Raspberry Pi : <a href="https://github.com/skrabban/mongo-nonx86">https://github.com/skrabban/mongo-nonx86</a>.</p>

<p>Un article permet de guider pas à pas à l'installation de MongoDB sur Raspberry Pi : <a href="http://elsmorian.com/post/24395639198/building-mongodb-on-raspberry-pi">http://elsmorian.com/post/24395639198/building-mongodb-on-raspberry-pi</a></p>

<p>Attention il faut compter 7 à 8 heures pour un build complet.</p>

<h2>Démonstration</h2>

<p>Elle a consisté à présenter et exécuter un programme Java qui va lire dans une base mongodb des données (événements Devoxx France précedemment récupérés) et affiche le résultat.</p>

<h2>Les slides sur Parleys</h2>

<p><a href="http://www.parleys.com/#play/515ac911e4b0ffdd7e058b9e">http://www.parleys.com/#play/515ac911e4b0ffdd7e058b9e</a></p>

<object width="600" height="395"><param name="movie" value="http://www.parleys.com/dist/share/parleysshare.swf"></param><param name="allowFullScreen" value="true"></param><param name="wmode" value="direct"></param><param name="bgcolor" value="#222222"></param><param name="flashVars" value="sv=true&pageId=515ac911e4b0ffdd7e058b9e" ></param><embed src="http://www.parleys.com/dist/share/parleysshare.swf" type="application/x-shockwave-flash" flashVars="sv=true&pageId=515ac911e4b0ffdd7e058b9e" allowfullscreen="true" bgcolor="#222222" width="395" height="395"></embed></object>


<h2>Bilan</h2>

<p>Une bonne introduction à Raspberry Pi avec une démonstration concrète de son utilisation.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Manipulez le bytecode]]></title>
    <link href="http://roddet.github.com/2012/06/manipulez-le-bytecode/"/>
    <updated>2012-06-21T22:45:00-04:00</updated>
    <id>http://roddet.github.com/2012/06/manipulez-le-bytecode</id>
    <content type="html"><![CDATA[<h2>Java et la philosophie du paquet cadeau</h2>

<p>Nous le savons, avec Java, nous travaillons avec un langage compilé. Notre code écrit en Java est transformé en bytecode (stocké dans des fichiers .class) pour ensuite être exécuté par la JVM. En plus de cette notion de compilation, Java ajoute une philosophie de "packaging". Nous nous plaisons bien dans cette philosophie de packaging parce que nous développons avec de nombreuses ressources et le fait d'avoir un paquet cadeau qui représente le fruit de notre travail nous facile la tâche lorsque l'on veut l'offrir à un environnement d'exécution.</p>

<table><tr>
  <td width="30%"><img src="/images/manipbytecode/cadeau.png"/></td>
  <td width="70%">Cette philosophie du paquet cadeau a néanmoins un gros inconvénient, il n'est pas simple de le modifier même pour des ajustements minimes. Par exemple, votre équipe de test a qualifié votre livrable mais vous aurez bien voulu tracer l'exécution d'une méthode critique. Pour le faire, vous êtes traditionnellement obligé de recompiler, refaire le paquet cadeau et là vous hésitez ! Vous n'êtes jamais sûr à 100% que vous n'avez pas introduit de régression et vous savez qu'en cas de problème retirer votre code va vous obliger à refaire votre paquet cadeau pour la production.
<br/>Un autre exemple, vous avez un bug que vous ne reproduisez qu'en environnement de production, vous auriez aimé tracer l'exécution d'une méthode pour investiguer. Là aussi vous partez sur la constitution d'un nouveau cadeau avec le risque d'introduire encore plus de regression et le retour arrière ne sera pas aisé à mettre en oeuvre.</td>
</tr></table>


<br/>


<h2>Notre façon de coder influencée par le packaging</h2>

<p>Le fait de savoir qu'en production une modification du code est extremement difficile à faire passer, nous allons mettre un peu de tout et n'importe quoi dans notre application.
Nous allons notamment ajouter du code de debug comme :
<code>java
if(logger.isDebugEnabled()){
   logger.debug("Au cas où j'aurai un bug...");
}
</code>
Ou encore pour mesurer des temps d'exécution, on va ajouter du code en début et fin de méthode.
Ces parties de code qui n'ont rien avoir avec notre application, nous dépensons de l'énergie pour les écrire et surtout nous ne savons pas souvent s'ils sont pertinents. Nous essayons d'être le plus générique possible et à chaque fois nous nous faisons avoir... La trace n'est pas adapté à notre cas et nous devons modifier le code, refaire le paquet cadeau. Et pire, combien de NullPointerException nous avons dû corriger sur ces morceaux de code qui n'ont rien avoir avec le fonctionnement de notre application ?</p>

<h2>Java 5 et ses agents "secrets" pour nous aider</h2>

<p>Depuis le JDK 1.5, nous avons la possibilité d'instrumenter un programme. J'entends ici, par instrumenter, la possibilité d'ajouter des instructions à nos classes déjà compilées (le bytecode) au runtime. Cette instrumentation peut être effectuée par le biais d'un agent que l'on fournit au lancement d'une application. Un agent se présente sous la forme d'un JAR et est fourni grâce au paramètre -javaagent:.
Nous progressons dans notre problématique, avec le mécanisme des agents nous pouvons séparer le code de l'application du code nous permettant de faire nos analyses. Nous ne sommes plus obligés de modifier le paquet cadeau généré, validé par nos équipes de test. C'est une avancée intéressante, car si notre code périphérique introduit des regressions, il suffit de redémarrer l'application sans l'agent pour supprimer la regression.</p>

<h2>Notre premier agent</h2>

<p>Pour qu'un JAR puisse être utilisé comme un agent, il faut qu'il reste certaines conditions :
Avoir dans son fichier MANIFEST au moins l'attribut Premain-Class
L'attribut Premain-Class doit avoir comme valeur une classe existante qui contient au moins la méthode
``` java
public static void premain(String agentArgs, Instrumentation instr){</p>

<p>}
```
Pour créer un projet Java générant un JAR, je ne sais plus comment on fait sans Maven :-) L'exemple qui suit reste évidemment valable à condition de l'adapter à votre outil de génération de JAR (Eclipse, Netbeans, JDK, Ant, vos mains,...).</p>

<ul>
<li><p>Création du projet agent-simple
<code>
mvn archetype:generate -DgroupId=com.roddet -DartifactId=agent-simple -Dversion=1.0
</code></p></li>
<li><p>Créer une classe qui sera le point d'entrée de notre agent
```java
package com.roddet.agent.simple;</p></li>
</ul>


<p>import java.lang.instrument.Instrumentation;</p>

<p>public class MySimpleAgent {</p>

<pre><code>public static void premain(String agentArgs, Instrumentation instr){
}
</code></pre>

<p>}
<code>
Pour mettre à jour le fichier MANIFEST avec Maven on peut ajouter la configuration du plugin maven-jar-plugin comme suit :
</code> xml
<build>
  <pluginmanagement></p>

<pre><code>&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;groupid&gt;org.apache.maven.plugins&lt;/groupid&gt;
    &lt;artifactid&gt;maven-jar-plugin&lt;/artifactid&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;configuration&gt;
      &lt;archive&gt;
        &lt;manifestentries&gt;
          &lt;premain-class&gt;com.roddet.agent.simple.MySimpleAgent&lt;/premain-class&gt;
        &lt;/manifestentries&gt;
      &lt;/archive&gt;
    &lt;/configuration&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p>  </pluginmanagement>
</build>
```
Il ne reste plus qu'à écrire du code dans la méthode premain de la classe MySimpleAgent et lancer une application avec le paramètre -javaagent.</p>

<h2>Un exemple concret de l'utilisation d'un agent</h2>

<p>Pour illustrer la modification du bytecode, nous allons considérer une application basique faite avec Swing qui affiche un champ de saisie et un bouton.</p>

<p><img src="/images/manipbytecode/swing-app.png" alt="/images/manipbytecode/swing-app.png" /></p>

<p>La classe principale de cette application est la suivante :
``` java
package com.roddet.swing.app;</p>

<p>import javax.swing.<em>;
import java.awt.</em>;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.IOException;</p>

<p>public class SwingFrame extends JFrame implements ActionListener {</p>

<pre><code>private JTextField swingText = new JTextField(10);
private JButton swingBtn = new JButton("Click!");

public SwingFrame() {
    init();
}

private void init() {
    this.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
    swingBtn.addActionListener(this);
    this.setLayout(new GridLayout());
    this.add(swingText);
    this.add(swingBtn);
    this.pack();
}

@Override
public void actionPerformed(ActionEvent actionEvent) {

}


public static void main(String[] args) throws IOException {
    JFrame app = new SwingFrame();
    app.setVisible(true);
}
</code></pre>

<p>}
```
Lors du clic sur le bouton "Click!", la méthode actionPerformed est exécuté. Pour le moment, ce clic ne produit aucun résultat.
Nous créons un paquet "cadeau" de cette application qui s'appelle swing-app-1.0.jar.</p>

<p>Notre objectif avec cet exemple est de modifier le comportement du clic sur le bouton pour qu'il affiche du texte dans la zone de saisie sans modifier notre paquet.</p>

<p>Pour lancer l'application, il suffit d'exécuter la commande :
<code>
java -jar swing-app-1.0.jar
</code>
Pour exécuter l'application avec notre agent :
<code>
java -javaagent:agent-simple-1.0.jar -jar swing-app-1.0.jar
</code>
Pour le moment, il ne se passe rien (pas de comportement spécifique défini dans l'agent).
Pour nous assurer que le code de notre agent est bien exécuté, nous ajoutons le traditionnel System.out.println dans notre agent comme ceci :</p>

<p>``` java
public class MySimpleAgent {</p>

<pre><code>public static void premain(String agentArgs, Instrumentation instr){
  System.out.println("I'm your secret agent");
}
</code></pre>

<p>}
```
A l'exécution, la chaine de caractère s'affiche, rien de bien intéressant pour le moment.</p>

<p>La modification du bytecode d'une application passe par le mécanisme de "transformer" que l'on peut ajouter à notre objet instr de type java.lang.instrument.Instrumentation. Un transformer est une classe qui implémente l'interface java.lang.instrument.ClassFileTransformer.</p>

<p>Créons alors notre "transformer" MySimpleTransformer avec un affichage dans la console des classes sur lesquels on peut intervenir :
``` java
package com.roddet.agent.simple;</p>

<p>import java.lang.instrument.ClassFileTransformer;
import java.lang.instrument.IllegalClassFormatException;
import java.security.ProtectionDomain;</p>

<p>public class MySimpleTransformer implements ClassFileTransformer {</p>

<pre><code>@Override
public byte[] transform(ClassLoader classLoader, String className, Class aClass,
                             ProtectionDomain protectionDomain, byte[] bytes)
                                              throws IllegalClassFormatException {
  System.out.println("I can modify class : " + className);
  return bytes;
}
</code></pre>

<p>}
<code>
Et appliquons notre transformer à l'objet instr
</code> java
public class MySimpleAgent {</p>

<pre><code>public static void premain(String agentArgs, Instrumentation instr) {
    System.out.println("I'm your secret agent");
    instr.addTransformer(new MySimpleTransformer());
}
</code></pre>

<p>}
<code>
A l'exécution, on obtient :
</code>
   I'm your secret agent
   I can modify class : com/roddet/swing/app/SwingFrame
   I can modify class : javax/swing/JFrame
   I can modify class : javax/swing/WindowConstants
   I can modify class : javax/accessibility/Accessible
   I can modify class : javax/swing/RootPaneContainer
   I can modify class : javax/swing/TransferHandler$HasGetTransferHandler
   I can modify class : java/awt/Frame
   ..... (la liste est longue)
```
On remarque que l'on peut modifier non seulement notre classe mais aussi les classes du JDK chargées.
Pour modifier le bytecode d'une classe, il faut modifier le tableau byte[] retourné par la méthode transform au moment où elle est exécutée pour notre classe.</p>

<p>C'est là où ça se complique ...:-) Qu'est-ce que l'on va mettre dans ce tableau byte[] ? Comment va t-on construire un tableau de byte conforme au spécification du bytecode Java (bon magic number, version de java, bytecode, ...) ?
Heureusement plusieurs techniques/outils nous permettent de nous simplifier la tâche ou de tricher un peu.
On va commencer par la triche :-)
Nous pouvons modifier le code SwingFrame en complétant la méthode actionPerformed :
<code>java
public void actionPerformed(ActionEvent actionEvent) {
  this.swingText.setText(new Date().toString());
}
</code>
Nous pouvons récupérer le fichier SwingFrame.class correspondant et le mettre dans le répertoire de ressources (src/main/resources) du projet maven agent-simple. Ce fichier sera alors dans le classpath d'exécution de notre agent.</p>

<p>Nous pouvons modifier notre transformer comme suit pour qu'il remplace le bytecode de la classe SwingFrame par celui que l'on vient de générer :
``` java
public class MySimpleTransformer implements ClassFileTransformer {</p>

<pre><code>@Override
public byte[] transform(ClassLoader classLoader, String s, Class aClass,
                        ProtectionDomain protectionDomain, byte[] bytes)
                        throws IllegalClassFormatException {
    if (s.equals("com/roddet/swing/app/SwingFrame")) {
        try {
            bytes = getSwingFrameModifiedByteCode();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return bytes;
}

private byte[] getSwingFrameModifiedByteCode()
                               throws IOException, URISyntaxException {
    InputStream fileInputStream = Thread.currentThread().getContextClassLoader()
                                     .getResourceAsStream("SwingFrame.class");
    ByteArrayOutputStream output = new ByteArrayOutputStream();
    byte[] buffer = new byte[1024 * 4];
    int n = 0;
    while (-1 != (n = fileInputStream.read(buffer))) {
        output.write(buffer, 0, n);
    }
    fileInputStream.close();
    return output.toByteArray();
}
</code></pre>

<p>}
```
En exécutant sans agent (java -jar swing-app-1.0.jar), un clic sur le bouton "Click" ne produit rien comme résultat.</p>

<p>Avec une exécution avec agent
<code>
java -javaagent:agent-simple-1.0.jar -jar swing-app-1.0.jar
</code>
, la date/heure courante s'affiche après un clic sur le bouton.</p>

<p>![/images/manipbytecode/swing-app-with-agent.png]</p>

<p>Le JDK 5 nous offre ainsi une flexibilité sur notre application en production. Nous pouvons modifier un ensemble de classes et les remplacer directement en production en redémarrant l'application avec un agent. En cas de regression, il suffit de retirer l'agent.</p>

<h2>Java 6 va encore plus loin</h2>

<p>Depuis Java 6, il est possible d'instrumenter l'exécution d'une application après son lancement. Le package com.sun.tools.attach a été ajouté et fournit une API permettant d'ajouter, de supprimer un agent. Pour montrer l'utilisation de cet API, nous allons créer un programme permettant de connecter un agent à un programme en cours d'exécution.</p>

<p>Créons un projet Maven agent-live-installer
<code>
mvn archetype:generate -DgroupId=com.roddet -DartifactId=agent-live-installer -Dversion=1.0
</code>
Créons une classe principale qui fait le lien entre un agent et le pid d'une application en cours d'exécution.
``` java
package com.roddet.agent;</p>

<p>import com.sun.tools.attach.VirtualMachine;</p>

<p>public class MyAgentLiveInstaller {</p>

<pre><code>public static void main(String[] args) throws Exception {
    VirtualMachine vm = null;
    try {
        // 2 parameters for this execution
        if(args.length &lt; 2) {
            throw new RuntimeException("Two parameters is mandatory : "
                                                  + "pid and agent JAR path");
        }

        String pid = args[0];
        String agent = args[1];

        System.out.println("Attaching agent " + agent
                                + " to application with pid " + pid);

        // Attach VM to running application with his pid
        vm = VirtualMachine.attach(pid);

        // load agent into target VM
        vm.loadAgent(agent);

        System.out.println("Agent loaded + " + vm.getAgentProperties());

    } finally {
        if(vm != null) {
            vm.detach();
        }
    }

}
</code></pre>

<p>}
<code>
Pour qu'un agent puisse être chargé dynamiquement, deux conditions :
la classe principale de l'agent doit avoir une méthode agentmain comme ci-dessous :
</code> java</p>

<p>public class MySimpleAgent {</p>

<pre><code>public static void premain(String agentArgs, Instrumentation instr) {
    System.out.println("I'm your secret agent");
    instr.addTransformer(new MySimpleTransformer());
}

public static void agentmain(String agentArgs, Instrumentation instr) throws
                                                   UnmodifiableClassException {
    System.out.println("I'm your dynamic secret agent");
    instr.addTransformer(new MySimpleTransformer(), true);
    instr.retransformClasses(getModifiedClasses(instr));
}

private static Class[] getModifiedClasses(Instrumentation instr) {
    List&lt;Class&lt;?&gt;&gt; modifiableClasses = new ArrayList&lt;Class&lt;?&gt;&gt; ();
    for(Class aClass : instr.getAllLoadedClasses()) {
        if(instr.isModifiableClass(aClass)){
            modifiableClasses.add(aClass);
        }
    }
    Class[] classesTab = new Class[modifiableClasses.size()];
    int i = 0;
    for (Class aClass : modifiableClasses){
        classesTab[i] = aClass;
        i++;
    }
    return classesTab;
}
</code></pre>

<p>}
```
le fichier MANIFEST doit avoir l'attribut Agent-Class. Nous pouvons l'ajouter à la configuration Maven. Nous ajoutons également les attributs Can-Redefine-Classes et Can-Retransform-Classes pour donner les droits de modifications à l'agent.</p>

<p>``` xml
<build>
  <pluginmanagement></p>

<pre><code>&lt;plugins&gt;
  &lt;plugin&gt;
    &lt;groupid&gt;org.apache.maven.plugins&lt;/groupid&gt;
    &lt;artifactid&gt;maven-jar-plugin&lt;/artifactid&gt;
    &lt;version&gt;2.4&lt;/version&gt;
    &lt;configuration&gt;
      &lt;archive&gt;
        &lt;manifestentries&gt;
          &lt;premain-class&gt;com.roddet.agent.simple.MySimpleAgent&lt;/premain-class&gt;
          &lt;agent-class&gt;com.roddet.agent.simple.MySimpleAgent&lt;/agent-class&gt;
          &lt;can-retransform-classes&gt;true&lt;/can-retransform-classes&gt;
          &lt;can-redefine-classes&gt;true&lt;/can-redefine-classes&gt;
        &lt;/manifestentries&gt;
      &lt;/archive&gt;
   &lt;/configuration&gt;
  &lt;/plugin&gt;
&lt;/plugins&gt;
</code></pre>

<p>  </pluginmanagement>
</build>
<code>
On peut exécuter l'application swing seule :
</code>
java -jar swing-app-1.0.jar
<code>
Pour avoir la liste des processus java tournant sur une machine, on peut utiliser la commande :
</code>
jps</p>

<p>   804
   1913 Jps
   1907 swing-app-1.0.jar
```
A ce stade si nous cliquons sur le bouton "Click!", il ne se passe rien.</p>

<p>Ensuite nous pouvons utiliser le programme agent-live-installer pour "attacher" un agent à un processus en cours d'exécution.
<code>
java -jar agent-live-installer-1.0.jar 1907 agent-simple-1.0.jar
</code>
Et là, sans redémarrer l'application swing-app, un clic sur bouton affiche la date/heure.
Il est également possible aussi de créer un programme qui détache un agent d'un processus.</p>

<p>Avec Java 6, nous devenons tout puissant. Nous pouvons modifier du code "en live" et retirer lorsque nous le souhaitons. La modification après le lancement de l'application a néanmoins des limites, on ne peut pas par exemple modifier la structure d'une classe.</p>

<h2>Quoi pour modifier le bytecode ?</h2>

<p>La procédure présentée précédemment permet d'adresser plusieurs cas mais elle n'est pas très pratique notamment pour instrumenter des classes dont nous n'avons pas les sources. Heureusement plusieurs outils peuvent nous aider à modifier le bytecode. Ils sont nombreux, voici les 3 plus populaires :</p>

<ul>
<li><a href="http://asm.ow2.org/">ASM</a> : propose une API de relativement bas niveau pour modifier nos classes. Il est à la base de nombreux frameworks comme Oracle TopLink, Cobertura, Groovy, JRuby, ... Une liste plus exhaustive est disponible ici.</li>
<li><a href="http://www.eclipse.org/aspectj/doc/released/progguide/index.html">AspectJ</a> : pionnier de la programmation orientée aspect, il permet de définir des comportements transverses de manière agréable (java ou xml) à une application. Il fournit un agent auquel on adjoint une configuration.</li>
<li><a href="http://www.jboss.org/byteman">Byteman</a>  : produit open source développé par JBoss qui permet de modifier le bytecode au démarrage d'une application ou sur une application en cours d'exécution. L'instrumentation d'une application se fait par le biais de règles très facile à lire et à mettre en oeuvre.</li>
</ul>


<h2>Quelques exemples avec Byteman</h2>

<p>Pour installer Byteman, télécharger puis décompresser le binaire ici.
Idéalement ajouter le répertoire [BYTEMAN_INSTALL]/bin dans le "Path" de votre système.</p>

<p>Règle 1 : tracer le clic sur le bouton "Click!"
Créer le fichier trace-click-swing-app.btm avec le contenu :
<code>
RULE trace click
CLASS com.roddet.swing.app.SwingFrame
METHOD actionPerformed(java.awt.event.ActionEvent)
IF TRUE
DO System.out.println("Click!");
ENDRULE
</code>
Lancer l'application swing-app :
<code>
java -jar swing-app-1.0.jar
</code></p>

<p><img src="/images/manipbytecode/swing-app-without-agent.png" alt="/images/manipbytecode/swing-app-without-agent.png" /></p>

<p>Un clic sur le bouton ne produit aucun résultat.</p>

<p>Utiliser la commande jps pour récupérer le pid du processus puis installer l'agent byteman avec la script bminstall.sh :
<code>
bminstall.sh 2276
</code>
Puis appliquer la règle trace-click-swing-app.btm :
<code>
bmsubmit.sh trace-click-swing-app.btm
</code>
Et là, quand on clique sur le bouton "Click!", la trace "Click!" apparait dans la console.</p>

<p>Règle 2 : mettre à jour le champ de saisie après un clic
Créer le fichier addText-swing-app.btm avec le contenu :
<code>
RULE addText on click
CLASS com.roddet.swing.app.SwingFrame
METHOD actionPerformed(java.awt.event.ActionEvent)
IF TRUE
DO $0.swingText.setText("Hello, it's magic!!")
ENDRULE
</code>
Le mot clé $0 est l'équivalent de "this".</p>

<p>L'exécution de bminstall.sh n'est nécessaire qu'un seule fois, on directement ajouter un deuxième agent.</p>

<p>Appliquer la règle addText-swing-app.btm :
<code>
bmsubmit.sh addText-swing-app.btm
</code>
Lors du clic sur le bouton, le message "Hello, it's magic!!" s'affiche.</p>

<p><img src="/images/manipbytecode/byteman-swing-app.png" alt="/images/manipbytecode/byteman-swing-app.png" /></p>

<p><a href="http://www.jboss.org/byteman">Byteman</a> permet d'aller loin dans l'écriture des règles notamment avec :
l'utilisation d'expression régulière pour définir un ensemble de classe
le choix plus précis de l'endroit à instrumenter grâce aux mots clés AT ENTRY, AT EXIT, AT LINE, AFTER READ, etc...
de retirer "à chaud" un agent chargé
de manipuler les paramètres d'entrées de méthode
une intégration avec JUnit pour nous aider à simuler des erreurs inattendues (exception due à une coupure réseau, ...)</p>

<h2>Qu'est-ce qu'on fait maintenant ?</h2>

<p>Nous avons vu qu'avec Java 5, nous étions capable de séparer le code de l'application aux problématiques transverses comme le logging. Avec Java 6, on peut effectuer des modifications de bytecode à chaud. Cette fonctionnalité est de plus en plus utilisée par des applications tierces, par exemple avec l'apparition de l'onglet "profiler" dans jvisualvm :</p>

<p><img src="/images/manipbytecode/jvisualvm-profiler.png" alt="/images/manipbytecode/jvisualvm-profiler.png" /></p>

<p>N'hésitons pas à :</p>

<ul>
<li>exploiter les possibilités de notre JVM
utiliser les outils de programmation orienté aspect comme Spring, AspectJ, etc..</li>
<li>nous servir des outils comme <a href="http://www.jboss.org/byteman">Byteman</a> pour des analyses sans devoir défaire notre paquet cadeau.</li>
</ul>


<p>Le code utilisé est disponible là : <a href="https://github.com/roddet/manip-bytecode">https://github.com/roddet/manip-bytecode</a>.</p>
]]></content>
  </entry>
  
</feed>
